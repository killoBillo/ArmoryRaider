<?php
/**
 * Questa classe si occupa di generare il menu in base
 * alle grant assegnate all'utente tramite il modulo rights.
 * 
 * @author Marco Chillemi as killo
 * @return array
 *
 */ 
class RaiderMenu {
	private $menu;
	private $itemInfo;
	private $logOutMenu;
	
	
	
	function __construct() {
		$this->itemInfo = array();
		$this->menu = array(
			'id'=>'mainmenu',
			'htmlOptions'=>array(
				'class'=>'nav',
			),
			'encodeLabel'=>false,
			'items'=>array(
				array('label'=>'Home', 'url'=>array('/site/index')),
			),
		);
//		$this->logOutMenu = array(
//			'id'=>'logout_menu',
//			'htmlOptions'=>array(
//				'class'=>'logout_menu',
//			),		
//			'items'=>array(
//				array(
//					'label'=>'['.Yii::app()->user->name.'] Menu', 
//					'url'=>'',
//					'items'=>array(
//						array('label'=>'My Profile', 'url'=>array('/user/profile')),
//						array('label'=>'Logout ['.Yii::app()->user->name.']', 'url'=>array('/site/logout')),
//					),
//				),
//			),
//		);
		$this->logOutMenu = array(
			'id'=>'logout_menu',
			'htmlOptions'=>array(
				'class'=>'nav pull-right',
			),		
			'items'=>array(
				array(
					'label'=>'Logout '.Yii::app()->user->name, 
					'url'=>array('/site/logout')
				),
			),
		);

		
		if(RaiderFunctions::isAdmin()){
			/**
			 *	Inserisco Setting in cima all'array, e sposto profile e logout in coda. 
			 */
//			$profile =  $this->logOutMenu['items'][0]['items'][0];
//			$logoutItem = $this->logOutMenu['items'][0]['items'][1];
//			
//			$this->logOutMenu['items'][0]['items'][0] 	= array('label'=>'Raider Settings', 'url'=>array('/config/admin'));
//			$this->logOutMenu['items'][0]['items'][1] 	= $profile;
//			$this->logOutMenu['items'][0]['items'][] 	= $logoutItem;
			 
		}
	}
	
	
	public function buildMenu() {
		$model = User::model()->findByPk(Yii::app()->user->getId());
		
		/**
		 * se il model � empty interrompo subito la costruzione del menu.
		 * N.B.: il $model � empty quando l'utente non � loggato.
		 */ 
		if(empty($model))
			return false;
			
		/**
		 * verifico se si tratta di un amministratore.
		 * il menù dell'amministratore segue un altro flusso, è composto
		 * soltanto di items di livello 1 che linkano alla action admin di ogni
		 * controller.
		 */	
		if (!RaiderFunctions::isAdmin()) {								// se l'utente loggato non è l'admin
			/**
			 * 
			 * Recupero le autorizzazioni dell'utente dalle tabelle del modulo Rights
			 * utilizzando le relations dei rispettivi models e ciclandomi i resultsets
			 * per passare ogni singolo model alla funzione populateItemInfo() che si
			 * occupa di popolare l'array di ItemInfo di supporto alla creazione del
			 * menu vero e proprio.
			 */			
			$authAss = $model->authassignments;
			$authItem = array();
			$authChild = array();
	
			foreach ($authAss as $k=>$model) {
				$this->populateItemInfo($model);
				$authItem[] = $model->itemname0;
			}
			foreach ($authItem as $k=>$model) {
				$this->populateItemInfo($model);
				$authChild[] = $model->authitemchildren;
			}
			foreach ($authChild as $k=>$models) {
				foreach ($models as $k1=>$model) {
					$this->populateItemInfo($model);
				}
			}
			
		}else{														// se è l'admin...
			$authItem = Authitem::model()->findAll();
			foreach($authItem as $k=>$model) {
				$this->populateItemInfo($model);
			}
		}
		
		$this->manageItemInfo();
	}
	
	
	
	
	
	/**
	 * Questa è la funzione che crea in modo vero e proprio il menu
	 * lo fa gestendo l'array di supporto che ci siamo costruiti $this->itemInfo.
	 * 
	 */
	private function manageItemInfo(){
		foreach ($this->itemInfo as $item=>$type) {
			if ($type == 1 && $item != 'Site.*') {						//se si tratta di un task/controller e non � 'Site.*' (es: Character.*)
				// $item è una stringa di tipo Character.*
				$label = str_replace('.*', '', $item);
				$this->menu['items'][] = array(
					'label'=>$label.'<b class="caret"></b>',
					'url'=>'#',
					'submenuOptions' => array( 'class' => 'dropdown-menu' ),
					'items'=>array(
//						array('label'=>'list', 'url'=>array('/'.$label.'/index')),
						array('label'=>'admin', 'url'=>array('/'.$label.'/admin')),
						array('label'=>'create', 'url'=>array('/'.$label.'/create')),
					),
		            'itemOptions' => array( 'class' => 'dropdown' ),
        		    'linkOptions' => array( 'class' => 'dropdown-toggle', 'data-toggle' => 'dropdown' ),					
				);
			} elseif ($type == 0 && !RaiderFunctions::isAdmin()) {		//se si tratta di una operation (type = 0) e l'utente NON è l'admin
				//item è una stringa di tipo Character.Create
				$labels = explode('.', $item);
				
				//creo l'item di livello 1 (nel caso non esistesse già)
				if(!$this->getKey($labels[0]) && !array_key_exists($labels[0].'.*', $this->itemInfo)) {
					$this->menu['items'][] = array(
						'label'=>$labels[0],
						'url'=> '#',
						'submenuOptions' => array( 'class' => 'dropdown-menu' ),
						'items'=>array(),
		            	'itemOptions' => array( 'class' => 'dropdown' ),
        		    	'linkOptions' => array( 'class' => 'dropdown-toggle', 'data-toggle' => 'dropdown' ),					
//						'htmlOptions'=>array(
//							'class'=> 'dropdown li_father',
//						),
					);
				}
				
				//creo l'item figlio di livello 2 (nel caso in non fosse gi� assegnato tutto il task all'utente es: Character.*)
				if(!array_key_exists($labels[0].'.*', $this->itemInfo)){ 
					$this->menu['items'][$this->getKey($labels[0])]['items'][] = array(
						'label'=>$labels[1],
						'url'=>array('/'.$labels[0].'/'.$labels[1]),
						'htmlOptions'=>array(
							'class'=>'dropdown-toggle',
							'data-toggle'=>'dropdown'
						),
					);
				}
			}
		}
	}
	
	
	
	/**
	 * 
	 * Questa funzione, passata come stringa la label di un item (es: User),
	 * restituisce la chiave numerica dell'array 'items' ($this->menu['items']).
	 * Utilizzata per trovare l'item padre (task) di un item figlio (operation)
	 * per generare correttamente il menu.
	 * 
	 * Torna FALSE se nn trova l'item richiesto.
	 * @param unknown_type $string
	 */
	private function getKey($string) {
		foreach ($this->menu['items'] as $k=>$array) {
			foreach ($array as $k1=>$v) {
				if($v == $string) {
					return $k;
				}
			}
		}

		return FALSE;
	}
	
	
	
	
	/**
	 * Funzione pubblica, restituisce l'array $this->menu
	 * Es: Yii::app()->user->raiderMenu->getMenu();
	 * @return array
	 */
	public function getMenu() {
		return $this->menu;
	}
	/**
	 * restituisce l'array $this->logOutMenu
	 * Es: Yii::app()->user->raiderMenu->getLogOutMenu();
	 * @return array
	 */
	public function getLogOutMenu() {
		return $this->logOutMenu;
	}
	
	

	/**
	 * Popola l'array $this->itemInfo
	 * 
	 * @param obj $model
	 */
	private function populateItemInfo($model) {
		$modelName = get_class($model);
		
		switch ($modelName) {
			case 'Authassignment':
				$this->parseAuthAss($model);
				break;
				
			case 'Authitem':
				$this->itemInfo[$model->attributes['name']] = $model->attributes['type'];
				break;

			case 'Authitemchild':
				$this->parseAuthItemChild($model);
				break;
		}
	}
	
	/**
	 * Utilizzate in populateItemInfo() per parsare model di tipo
	 * 'authassignment' e 'authitemchild'.
	 * 
	 * @param obj $model
	 */
	private function parseAuthAss($model) {
		$obj = $model->itemname0;
		$this->itemInfo[$obj->attributes['name']] = $obj->attributes['type'];
	}
	private function parseAuthItemChild($model) {
		$obj = $model->child0;
		$this->itemInfo[$obj->attributes['name']] = $obj->attributes['type'];
	}
	
	
	
}// EOF RaiderMenu Class
?>